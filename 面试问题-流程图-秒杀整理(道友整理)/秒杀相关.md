

[toc]



# 一、秒杀需要考虑什么问题？



秒杀业务的根本在于<font color = orange>**应用缓存提高并发量，减少数据库访问**</font>。使用mq缓冲将大流量数据进行削峰填谷，另外注意接口的防刷限流，还有就是如何解决超卖问题。

**并发的根源在于数据库，通常采用缓存+队列的方式减少数据库访问，降低访问速度。**可以采用redis+mq的方式实现。

## 1. 数据库的设计

- 秒杀业务的商品和订单单独设表，不要和正常商品和商品订单混合一起。表格数据足够少，才能**保证查询和写入速度**。

- 订单表将用户id和商品id设置为唯一索引，这样能**保证同一个用户不会购买两件相同的秒杀商品**。

- 秒杀商品表商品库存更新语句添加>0条件,**保证商品不会超卖**。（我们项目中是在controller层就做了判断，如果库存已经小于0，那么我们直接拒绝请求，防止多余的压力打到数据库上面）

```mysql
update miaosha_goods set stock_count = stock_count - 1 where goods_id = #{goodsId} and stock_count > 0
```



## 2. 使用redis + JWT 建立分布式鉴权（登录问题）

#### **用户模块**

- 注册&激活：

    | 1. 注册时校验参数                                            | @Vaild 注解实现                                           |
    | ------------------------------------------------------------ | :-------------------------------------------------------- |
    | 2. 注册成功的话，将用户信息存储到数据库中                    | 密码使用MD5加密算法进行散列                               |
    | 3. 向用户所写的邮箱发送一个包含着激活链接的邮件，用户点击链接即可完成激活，数据库中有对应的激活表，更改用户的激活状态。 | 使用的springboot 自带的 JavaMailSender 完成发送邮件的功能 |

- 登录： 

    | 根据表单中提交的用户名和密码，去数据库进行查询               |                                                              |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 如果查询成功，根据用户id去生成一个JWT，放到cookies的access_token中，作为登录凭证 | 此时，要先对用户id进行AES加密（防止被破解），然后使用HMAC256签名算法生成JWT，防止JWT被篡改。 |

- 验证：

    从cookies中取出access_token的数据，取出payload中的数据，到数据库中进行复查，返回查询结果

- 登出:

    将cookies的maxAge直接设为0



## 3. 使用拦截器，验证所有接口的用户信息是否合法，并将用户信息保存在上下文中

 AccessInterceptor（自定义）继承HandlerInterceptorAdapter，实现 preHandle方法，根据token将用户信息从redis取出放入上下文中，上下文类使用ThreadLocal保存：

```java
private static ThreadLocal<MiaoshaUser> userHolder = new ThreadLocal<MiaoshaUser>();
```



## 4. 秒杀安全防护，限流防刷

1. **（限流）**使用令牌桶算法，通过限制令牌的生成速率，进行限流。
2. 秒杀开始前使用公式验证码进行验证，可用技术：scriptEngine
3. （**防刷**）隐藏秒杀接口，动态获取秒杀路径：路径可以使用localhost:8081/miaosha/{path}/doMiaosha的方式，{path}则通过动态方式生成，生成逻辑：UUID+盐值 然后使用MD5加密，同时保存至redis中一份：key使用用户id+商品id。
4. 添加访问限制注解(自定义注解)，为获取动态秒杀接口添加访问限制，例如：3分钟内限制访问5次。



## 5. 实现秒杀业务逻辑

**秒杀订单接口**

1. 进行一个是否售罄的检查，如果售罄直接返回 （redis 和 mysql 的一致性问题）
2. 获取一个令牌，获取成功，继续执行，获取失败，拒绝请求 
3. 在线程池中发起请求异步调用。
    - producer的监听器中的方法 TransactionMQProducer
        - 执行本地事务： 使用redission框架的分布式锁，本地事务（扣减库存，增加冻结库存）上锁。防止操作执行期间其他线程操作数据库导致超卖。
        - 查询本地事务状态：成功就进行commit，失败就重试
    - 秒杀服务的Service层调用sendMessage方法，发送消息，使用 @ transactional
    - consumer中复用Pipeline中的handler方法生成订单
    - 订单服务的Service层 使用 @ transactional

**亮点**

- 进行一个限流，基于令牌桶算法进行的一个限流，具体实现采用了Google开源工具包Guava提供了限流工具类RateLimiter

- rocketMQ延时消息，实现订单过期取消
- rocketMQ 事务消息，实现分布式事务和保证最终一致性（**base理论要求的**）



# 二、什么是超卖问题？怎么解决？

> 小何、小黄同时订单系统进行下单，由于订单系统的负载均衡策略，将小何的请求交给了订单系统1去处理，小黄的请求交给了订单系统2去处理
> 订单系统1查询了库存系统1，发现库存充足
> 订单系统2查询了库存系统2，发现库存充足
> 订单系统1、订单系统2都发现库存充足，于是分别通知库存系统1、库存系统2进行扣减库存，这就导致了库存系统中商品数量被扣减为负数的情况，也叫做库存超卖现象。
>
> 出现这个问题的根本原因是分布式集群节点之间无法共享synchronized锁。既然问题已经分析出来了，那么解决问题方案自然就呼之欲出了。（<font color=orange>**为什么需要分布式锁** </font>）我们可以使用一把能够跨应用共享的分布式锁，**锁住扣减库存的过程，这样一来在订单系统扣减库存的过程中，就不允许有其他的订单系统执行相同的操作。这样就可以保证了分布式集群环境下的线程安全性问题。**

# 三、什么是分布式事务？

## (尽量少说，坑很多，目前没有完美的分布式事务解决方案)

>1. 本地事务： ACID
>
>2. 分布式事务涉及到两个理论：
>
>    CAP理论：
>
>    ​	一致性
>
>    ​	可用性
>
>    ​	分区容错性（**必须保证的**）
>
>    BASE理论：
>
>    ​	基本可用
>
>    ​	软状态
>
>    ​	最终一致性
>
>**分布式事务**：分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器**分别位于不同的分布式系统的不同节点之上**。
>
>简单来说就是，一个大的操作由两个或者更多的小的操作共同完成，**而这些小的操作又分布在不同的网络主机上**。这些操作，要么全部成功执行，要么全部不执行。



# 四、为什么要使用分布式事务？有什么解决方案？

>## **分布式解决的问题？**
>
>第一个是业务的并发要求非常高，对应的业务操作不能在同一个数据库中完成，也就是说不能通过数据库本身的事务实现。
>
>第二个是资源的分布问题（比较常见），有的业务资源是部门A负责的，有的业务资源是部门B负责的，这样的情况下怎么实现一个事务。
>
>第三个是大时间跨度的问题，完成一个事务需要很长很长时间，这种情况怎么处理？
>
>## 问题：（考察资源分布不同的解决方法）
>
>**阶段一：**
>
>> 现在公司有一个业务，需要将用户的活跃值转换为积分。怎么实现这个功能？
>> 假设记录用户活跃值的表叫 active_account， 记录了用户积攒的活跃值。积分账户的表叫 point_account，记录了用户的积分余额。100活跃值可以兑换100积分。
>
>1. 开启一个事务
>2. 给对应的 active_account 中扣除 100活跃值。
>3. 给用户的point_account 中增加100积分。
>4. 提交事物，或者回滚事物。
>
>这个问题很简单，通常是大家接触最多的，可以直接通过本地事务来解决。
>
>**阶段二：**
>
>> 但现在有一个问题，用户活跃值的业务统一是由微服务A负责的。积分业务统一是由微服务B负责的。现在需要你设计一个新的服务C来实现转换的功能。你会怎么实现这个新的服务?
>
>**解决方案一：**
>
>1. 调用微服务A，扣除100活跃值。如果操作失败，直接返回失败。
>2. 调用微服务B，增加100积分。如果失败，调用微服务A执行回滚，并返回失败。
>3. 返回操作成功。
>
>这个方案有个问题，不能保证在第二步中一定能够执行微服务A的回滚。假设说用户的活跃值有个上限，比如150。用户原先有150的活跃值，在这个过程中又增加了10活跃值，所以如果回滚就会造成用户的活跃值变成160了，数据的一致性被破坏了。
>
>该方案的核心思想是补偿机制，假设没有活跃值上限的情况下该方案是不错，**性能较好**。
>
>**解决方案二：（2PC，二阶段提交）**
>
>1. 调用微服务A，扣除100活跃值，但是不要把改动commit到数据库中。
>2. 调用微服务B，增加100积分，但是不要把改动commit到数据库中。
>3. 如果1和2都成功，调用微服务A和B，让他们执行commit。否则执行rollback。
>4. 最后A，B执行完成后发送执行结果给C。
>
>同时这个方案在步骤1和2中记下undo和redo日志（数据库完成，确保数据原子性和持久性）。可以看到该方案解决了无法回滚的问题，因为相当于把数据库阻塞了，这样可以确保事务一定可以回滚。这个操作其实就是分布式事务中的XA Transaction，主流数据库都有支持，MySQL从5.5开始支持。
>
>该方案最大的好处可以**保证数据强一致**。但主要问题就是在执行过程中节点A和节点B都是处于阻塞状态的，对**性能的影响比较大**。三阶段提交协议也类似，就不提了。（在看对应的文档的时候，有几个同学提到单点问题，认为这是该方案的缺陷。假设如下场景，在执行到第3步时，C服务异常终止了，可能只给A服务发送了commit但是没给B服务发送commit。其实这个问题也很好解决，可以模仿MySQL做一个undo日志和redo日志）
>
><font color = orange>**解决方案三：可靠消息最终一致性事务**（**MQ中间件实现**）</font>
>
>可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方（消息消费者）一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。
>
>事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事务问题。
>
>因此可靠消息最终一致性方案要解决以下几个问题：
>
>1. **本地事务与消息发送的原子性问题**
>    本地事务与消息发送的原子性问题即：事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。**使用RocketMQ的事务消息**
>2. **事务参与方接收消息的可靠性**
>    事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。
>3. **消息重复消费的问题**
>    由于网络2的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。
>    要解决消息重复消费的问题就要实现事务参与方的方法幂等性。（使用redis，将messageID或者使用唯一的业务ID做判断，如果redis中已经有就拒绝请求）
>
>## 最后
>
>解决分布式事物的代价还是很大的，而不仅仅是通常认为的调用服务A，调用服务B那么简单。所以当需要使用分布式事务前一定要想一想能不能用普通的事务来解决，合适地使用技术才是最好的。



# 五、什么是分布式锁？

>分布式锁：就是在所有进程都能访问到的地方设置一个锁资源，让所有的进程来竞争锁资源，通过数据库、zk、redis都可以实现，但是要满足 **响应快，性能高，与业务无关**的要求，所以redis比较合适
>
>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个**分布式锁**。



订单编号：1957218085727063454

按格式填写下信息：
姓名： 王xx
身份证号：13020519950xxxxxxx
入职时间：2020.04
离职时间：2021.06
部门：技术部
岗位：Java开发工程师
开具时间：2021.06.28
公司全称：河北xxxx有限公司



这边做的都是纸质的银行薪资流水。
不知道怎么填写的，咨询我。
流水信息填写(举例)

【1】姓名：王xx
【2】在那里打印的流水：中国建设银行(开平新城分理处)
【3】你的银行卡号：623094001000046xxxx
【4】每月工资收入：13736.64    工资每月15日发（2月 在2月10日发 ）
（注意备注:实发的工资。计算薪资。http://www.rm1.cn/。发税前工资的话，这边统一按个税计算器最低基数计算）
【5】交易时间：
2021.04.01-2021.06.31
【6】打印日期：
2021.07.19
【7】公司名称：河北xxxx有限公司

【8】特殊要求： 年终奖 1个月 税后 14550.00元，2月10日发 ，和工资分开，发两笔

对于流水怎么做，有要求的在这里备注上。
例如:备注需要做年终奖，备注上几月发，金额多少。（年终奖扣税）